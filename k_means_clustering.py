# -*- coding: utf-8 -*-
"""K-Means Clustering

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1LwXjM-OSTIyuF6TlUpcgwEqmj2KIsXnD

Facebook Marketplace Dataset
"""

import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
import seaborn as sns
from sklearn.cluster import KMeans
from sklearn.preprocessing import LabelEncoder, MinMaxScaler

dataset = pd.read_csv('/content/Facebook_Marketplace_data.csv')

dataset.shape

dataset.head()

dataset.info()

unique_status_ids_count = dataset['status_id'].nunique()
print("Number of different types of variables in the 'status_id' column:")
print(unique_status_ids_count)

dataset.status_published.value_counts()

dataset.status_published.nunique()

dataset.drop(columns=['Column1', 'Column2', 'Column3', 'Column4'], inplace=True)

"""How does the time of upload (`status_published`)  affects the `num_reaction`?"""

dataset['status_published'] = pd.to_datetime(dataset['status_published'])

dataset['hour'] = dataset['status_published'].dt.hour
dataset['day_of_week'] = dataset['status_published'].dt.dayofweek
dataset['day_of_month'] = dataset['status_published'].dt.day
dataset['month'] = dataset['status_published'].dt.month
dataset['year'] = dataset['status_published'].dt.year

plt.figure(figsize=(10, 6))
plt.scatter(dataset['status_published'], dataset['num_reactions'], alpha=0.5)
plt.title('Number of Reactions over Time')
plt.xlabel('time published')
plt.ylabel('Number of Reactions')

plt.show()

plt.figure(figsize=(10, 6))
plt.scatter(dataset['hour'], dataset['num_reactions'], alpha=0.5)
plt.title('Number of Reactions over Time')
plt.xlabel('hour')
plt.ylabel('Number of Reactions')

plt.show()

plt.figure(figsize=(10, 6))
plt.scatter(dataset['day_of_week'], dataset['num_reactions'], alpha=0.5)
plt.title('Number of Reactions over Time')
plt.xlabel('Day of Week')
plt.ylabel('Number of Reactions')

plt.show()

"""Is there a correlation between the number of reactions (num_reactions) and other engagement metrics such as comments (num_comments) and shares (num_shares)? If so, what is the strength and direction of this correlation?"""

columns_of_interest = ['num_reactions', 'num_comments', 'num_shares']
dataset_selected = dataset[columns_of_interest]

correlation_matrix = dataset_selected.corr()

print(correlation_matrix)

"""What is the average value of num_reaction, num_comments, num_shares for each post type?"""

average_values = dataset.groupby('status_type').agg({
    'num_reactions': 'mean',
    'num_comments': 'mean',
    'num_shares': 'mean'
}).reset_index()

print(average_values)

dataset.drop(columns=['status_id', 'status_published'], inplace=True)

"""What is the count of different types of posts in the dataset?"""

dataset.status_type.nunique()

dataset.info()

dataset.head()

"""Using the columns status_type, num_reactions, num_comments, num_shares, num_likes, num_loves, num_wows, num_hahas, num_sads, and num_angrys to train a K-Means clustering model on the Facebook Live Sellers dataset."""

X = dataset
y= dataset['status_type']
print(X.head(2))
print(y.head(2))

from sklearn.preprocessing import LabelEncoder

le = LabelEncoder()

X['status_type'] = le.fit_transform(X['status_type'])

y = le.transform(y)

summary = X.describe()
print(summary)

X.head()

cols = X.columns

from sklearn.preprocessing import MinMaxScaler

ms = MinMaxScaler()

X = ms.fit_transform(X)

X = pd.DataFrame(X, columns=[cols])

wcss=[]

for i in range(1,11):
  kmeans=KMeans(n_clusters=i,init='k-means++',random_state=42)
  kmeans.fit(X)
  wcss.append(kmeans.inertia_)

"""Using the elbow method to find the optimum number of clusters."""

plt.plot(range(1, 11), wcss)
plt.xlabel('Number of clusters')
plt.ylabel('WCSS')
plt.title('Elbow Method')
plt.show()

kmeans = KMeans(n_clusters=2,random_state=42)

kmeans.fit(X)

labels = kmeans.labels_

correct_labels = sum(y == labels)

print("Result: %d out of %d samples were correctly labeled." % (correct_labels, y.size))

print('Accuracy score: {0:0.2f}'. format(correct_labels/float(y.size)))

kmeans = KMeans(n_clusters=3,random_state=42)

kmeans.fit(X)

labels = kmeans.labels_

correct_labels = sum(y == labels)

print("Result: %d out of %d samples were correctly labeled." % (correct_labels, y.size))

print('Accuracy score: {0:0.2f}'. format(correct_labels/float(y.size)))

kmeans = KMeans(n_clusters=4,random_state=42)

kmeans.fit(X)

labels = kmeans.labels_

correct_labels = sum(y == labels)

print("Result: %d out of %d samples were correctly labeled." % (correct_labels, y.size))

print('Accuracy score: {0:0.2f}'. format(correct_labels/float(y.size)))

"""Even though 2 is the optimum number of clusters, 4 clusters provide one percent more efficiency"""

